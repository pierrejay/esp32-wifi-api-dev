<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>APIServer Library Documentation</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
        }
        h1, h2, h3 { 
            color: #333;
            margin-top: 2rem;
        }
        code {
            font-family: Monaco, Consolas, "Liberation Mono", Menlo, Courier, monospace;
            background: #f1f5f9;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-size: 0.8em;
        }
        pre {
            font-family: Monaco, Consolas, "Liberation Mono", Menlo, Courier, monospace;
            background: #f1f5f9;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.8em;
        }
        .note {
            background: #e0f2fe;
            border-left: 4px solid #2563eb;
            padding: 1rem;
            margin: 1rem 0;
        }
        .warning {
            background: #fef2f2;
            border-left: 4px solid #dc2626;
            padding: 1rem;
            margin: 1rem 0;
        }
        .directory-tree {
            font-family: monospace;
            white-space: pre;
            margin: 1rem 0;
            padding: 1rem;
            background: #f8fafc;
            border-radius: 8px;
        }
        .implementation-note {
            background: #f0fdf4;
            border-left: 4px solid #16a34a;
            padding: 1rem;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
    <h1>APIServer Library Documentation</h1>
    
    <h2>Table of Contents</h2>
    <ul>
        <li><a href="#architecture">Architecture</a></li>
        <li><a href="#implementation">API Implementation Pattern</a></li>
        <li><a href="#methods">RPC Method Declaration</a></li>
        <li><a href="#documentation">Auto-Documentation</a></li>
        <li><a href="#custom">Creating a Custom API Server</a></li>
        <li><a href="#details">Implementation Details</a></li>
    </ul>

    <h2 id="architecture">Architecture</h2>
    
    <h3>Overview</h3>
    <p>
        The APIServer library addresses a common challenge in embedded systems development: creating maintainable and extensible APIs for IoT devices. Traditional approaches often lead to tightly coupled code where business logic, API endpoints, and communication protocols are intertwined, making it difficult to modify or extend functionality.
    </p>

    <h3>Key Challenges & Features</h3>
    <ul>
        <li>Separation of concerns between business logic and API implementation</li>
        <li>Intuitive route/method declaration</li>
        <li>Automatic API documentation generation</li>
        <li>Real-time event notifications support</li>
        <li>Seamless integration with various protocols (HTTP, WebSocket, MQTT, Serial, etc.)</li>
        <li>Support for nested objects in parameters and responses</li>
        <li>Facilitating the addition of new protocols with minimal changes</li>
    </ul>

    <h3>Core Components</h3>
        <ul>
            <li><strong>APIServer (Master Object)</strong>
                <ul>
                    <li>Central manager of API methods</li>
                    <li>Registers methods and their handlers</li>
                    <li>Manages automatic documentation</li>
                    <li>Coordinates different protocol endpoints</li>
                    <li>Broadcasts events</li>
                </ul>
            </li>
            <br/>
            <li><strong>APIEndpoint (Class)</strong>
                <ul>
                    <li>Abstract base class for protocol servers</li>
                    <li>Wrapper for HTTP, WebSocket, Serial, MQTT...</li>
                    <li>Declares supported capabilities (getter, setter, event)</li>
                </ul>
            </li>
            <br/>
            <li><strong>APIMethod (Structure)</strong>
                <ul>
                    <li>Type (GET/SET/EVT)</li>
                    <li>Stores parameters, response & callback</li>
                    <li>Builder pattern for declaration & auto-documentation</li>
                </ul>
            </li>
        </ul>

    <h2 id="implementation">API Implementation Pattern</h2>

    <h3>Process</h3>
    <ol>
        <li>Create dedicated API interface class for each component (e.g. <code>WiFiManagerAPI.h</code>)</li>
        <li>Declare API methods, events & handlers (setters/getters with business logic)</li>
        <li>Declare & initialize API objects & endpoints in main</li>
        <li>Poll regularly, or run within a task</li>
    </ol>
    <div class="warning">
        <strong>Error handling note:</strong>
        Parameter type/value checking & error handling is responsibility of business logic API interface.
        API Server only checks for presence of required parameters.
    </div>

    <h3>Basic Implementation Example</h3>
    <p>Example of implementing an HTTP APIServer for a WiFi Manager:</p>

    <div class="directory-tree">
wifimanager_app/
  ├── lib/
  │   ├── WiFiManager/
  │   │   ├── WiFiManager.cpp    // Business logic
  │   │   ├── WiFiManager.h      // Business logic
  │   │   └── WiFiManagerAPI.h   // Business logic API interface 
  │   ├── APIServer/     
  │   │   ├── APIServer.h        // Core functionality
  │   │   ├── APIEndpoint.h      // Abstract endpoint implementation
  │   │   ├── WebAPIEndpoint.h   // HTTP/WS server implementation
  │   │   └── (...)              // Custom endpoints implementation
  └── src/
      └── main.cpp               // Main app file</div>

    <div class="note">
        <strong>Implementation Note:</strong><br>
        Initialization consists of creating stack objects (globals), passing the server to the application API and endpoint, and declaring the methods to use.
    </div>

    <h4>Main Application Setup: main.cpp</h4>
    <pre>
#include "WiFiManager.h"
#include "WiFiManagerAPI.h"
#include "APIServer.h"
#include "WebAPIEndpoint.h"

WiFiManager wifiManager;  
APIServer apiServer;
WiFiManagerAPI wifiManagerAPI(wifiManager, apiServer);
WebAPIEndpoint webServer(apiServer, 80);

void setup() {
    apiServer.addEndpoint(&webServer);
    
    if (!wifiManager.begin()) {
       Serial.println("WiFiManager initialization error");
       while(1) {
           delay();
       }
     }
     
     apiServer.begin(); 
}

void loop() {
    wifiManager.poll();     // Polls WiFiManager utility
    wifiManagerAPI.poll();  // Polls WiFiManager API for events
    apiServer.poll();       // Polls API Server for client requests
}</pre>

    <h4>API Method Registration: WiFiManagerAPI.h</h4>
    <pre>
#include "WiFiManager.h"
#include "APIServer.h"

(...)  
    // GET wifi/scan
    _apiServer.registerMethod("wifi/scan",
        APIMethodBuilder(APIMethodType::GET, [this](const JsonObject* args, JsonObject& response) {
            _wifiManager.getAvailableNetworks(response);
            return true;
        })
        .desc("Scan available WiFi networks")
        .response("networks", {
            {"ssid", "string"},
            {"rssi", "int"},
            {"encryption", "int"}
        })
        .build()
    );
    
    // SET wifi/ap/config
    _apiServer.registerMethod("wifi/ap/config",
        APIMethodBuilder(APIMethodType::SET, [this](const JsonObject* args, JsonObject& response) {
            bool success = _wifiManager.setAPConfigFromJson(*args);
            response["success"] = success;
            return true;
        })
        .desc("Configure Access Point")
        .param("enabled", "bool")
        .param("ssid", "string")
        .param("password", "string")
        .param("channel", "int")
        .param("ip", "string", false)       // Optional parameter
        .param("gateway", "string", false)  // Optional parameter
        .param("subnet", "string", false)   // Optional parameter
        .response("success", "bool")
        .build()
    );
    
    // Other API Methods...
(...)</pre>

    <div class="note">
        <strong>Note:</strong> All initialized endpoints will automatically expose all API methods and autonomously execute client requests. The current design is not thread-safe, particularly when using asynchronous libraries like ESPAsyncWebserver, but this is not important if all API-related tasks are grouped into a task running on the same core as the interfaces (UART, TCP/IP...).
    </div>

    <h2 id="methods">RPC Method Declaration</h2>

    <h3>Method Types</h3>
    
    <h4>GET Methods</h4>
    <ul>
        <li>Read-only operations</li>
        <li>No required request parameters</li>
        <li>Always return a response object</li>
    </ul>
    <pre>
rpcServer.registerMethod("wifi/status",
    RPCMethodBuilder(RPCMethodType::GET, handler)
        .desc("Get WiFi status")
        .response("status", "object")
        .build()
);</pre>

    <h4>SET Methods</h4>
    <ul>
        <li>Modify system state</li>
        <li>Require request parameters</li>
        <li>Return success/failure response</li>
    </ul>
    <pre>
rpcServer.registerMethod("wifi/sta/config",
    RPCMethodBuilder(RPCMethodType::SET, handler)
        .desc("Configure Station mode")
        .param("ssid", "string")
        .param("password", "string")
        .response("success", "bool")
        .build()
);</pre>

    <h4>EVT Methods (Events)</h4>
    <ul>
        <li>Server-initiated notifications</li>
        <li>No request parameters</li>
        <li>One-way communication (server to client)</li>
    </ul>
    <pre>
rpcServer.registerMethod("wifi/events",
    RPCMethodBuilder(RPCMethodType::EVT)
        .desc("WiFi status updates")
        .response("status", "object")
        .build()
);</pre>

<h3>Broadcasting Events</h3>
<p>Unlike other methods, events must be called by the application API, for example to signal a status change.</p>

<pre>
StaticJsonDocument<1024> newState;           // Create new JsonDocument
JsonObject status = newState["status"].to<JsonObject>();
_wifiManager.getStatusToJson(status);        // Fetch wifi status
_apiServer.broadcast("wifi/events", status); // Push event</pre>

<div class="note">
    <strong>Note:</strong> Events are automatically transmitted to all endpoints that implement protocols handling events (Websocket, MQTT for example, defined in classes derived from APIEndpoint).
</div>

    <h3>Naming Patterns</h3>
    <ul>
        <li>Use hierarchical paths: <code>component/resource</code></li>
        <li>Use plural for collections: <code>clients/list</code></li>
        <li>Include action in path: <code>wifi/scan</code></li>
        <li>Clear & direct methods possible: <code>get_wifi_status</code></li>
    </ul>

    <h3>Nested Objects</h3>
    <p>The library supports nested objects at any depth level through recursive implementation.</p>

    <h4>Nested Object Example</h4>
    <pre>
.response("status", {
    {"wifi", {
        {"enabled", "bool"},
        {"rssi", "int"},
        {"config", {
            {"ssid", "string"},
            {"password", "string"}
        }}
    }}
})</pre>

    <h2 id="documentation">Auto-Documentation</h2>
    <p>
        The library automatically generates comprehensive API documentation in JSON format. This documentation is available through the <code>/api</code> endpoint and provides a complete description of all available methods, their expected parameters (required/optional), and response structures.
    </p>

    <h3>Example Generated Documentation</h3>
    <pre>
{
  "methods": [{
    "path": "wifi/status",
    "type": "GET",
    "desc": "Get WiFi status",
    "protocols": ["http", "websocket"],
    "response": {
      "ap": {
        "enabled": "bool",
        "connected": "bool",
        "clients": "int",
        "ip": "string",
        "rssi": "int"
      },
      "sta": {
        "enabled": "bool",
        "connected": "bool",
        "ip": "string",
        "rssi": "int"
      }
    }
  },
  {
    "path": "wifi/sta/config",
    "type": "SET",
    "desc": "Configure Station mode",
    "protocols": ["http"],
    "params": {
      "enabled": "bool",
      "network": {
        "ssid": "string",
        "password": "string",
        "security": {
          "type": "string",
          "certificates": {
            "ca": "string*",
            "client": "string*"
          }
        }
      }
    },
    "response": {
      "success": "bool",
      "error": "string*"
    }
  }]
}</pre>

    <h2 id="custom">Creating a Custom API Server</h2>
    <p>
        To create a new protocol server, inherit from the <code>APIEndpoint</code> class and implement the virtual methods.
    </p>

    <h3>Custom Endpoint Example</h3>
    <pre>
class MyCustomEndpoint : public APIEndpoint {
public:
    MyCustomEndpoint(APIServer& apiServer, uint16_t port) 
    : APIEndpoint(myServer) {
        addProtocol("custom", GET | SET | EVT);
    }

    void begin() override {   // Initialization
        _setupAPIRoutes();     // API routes & event setup
        _server.begin();      // Endpoint server start
    }

    void poll() override {    
        _processEventQueue(); // Periodic event queue processing
    }

    void handleGet(const String& path, const JsonObject* args, 
    JsonObject& response) override {
         (...) // GET request handling
    }

    void handleSet(const String& path, const JsonObject& args, 
    JsonObject& response) override {
         (...) // SET request handling
    }

    void pushEvent(const String& event, const JsonObject& data) override {
       (...) // Queuing events received from business logic
    }

private:
    MyCustomServer _server;
    std::queue<String> _eventQueue;
    
    void _setupAPIRoutes() {
       (...) // Register API methods & events with server
    }
    
    void _processEventQueue() {
       (...) // Broadcast events to clients
    }
};</pre>

    <div class="note">
        For more details on server implementation, see existing implementations (ESPAsyncWebserial, MQTT, Serial...).
    </div>

    <h2 id="details">Implementation Details</h2>

    <h3>Memory Management</h3>
    <ul>
        <li>Using <code>StaticJsonDocument</code> for JSON buffers</li>
        <li>Default size: 2048 bytes for documentation</li>
        <li>Fixed stack allocation, no dynamic memory allocation during runtime</li>
        <li>Vector sizes are determined at compile time</li>
    </ul>

    <div class="warning">
        <strong>Memory Considerations:</strong>
        <ul>
            <li>Be mindful of stack size when using deeply nested objects</li>
            <li>Monitor memory usage with maximum expected payload sizes</li>
            <li>Consider static allocation limits on your target platform</li>
        </ul>
    </div>

    <h3>Thread Safety</h3>
    <ul>
        <li>Mutex can be implemented if needed</li>
        <li>Limited queue size (10 messages)</li>
        <li>Minimum interval between notifications (50ms)</li>
    </ul>

    <div class="note">
        <strong>Implementation Note:</strong><br>
        The current implementation prioritizes simplicity and efficiency over thread safety. If you need thread-safe operation, consider implementing appropriate synchronization mechanisms.
    </div>

    <h3>Parameter Validation</h3>
    <p>Parameter validation is intentionally simple:</p>
    <ul>
        <li>Verification of required parameters presence</li>
        <li>No type validation (handled by business logic)</li>
        <li>No recursive validation of nested objects (level 1 verification: object)</li>
        <li>Invalid configurations cause compilation errors</li>
    </ul>

    <div class="note">
        <strong>Design Philosophy:</strong><br>
        The library focuses on providing a robust foundation while allowing business logic to implement specific validation requirements. This separation of concerns ensures flexibility while maintaining code clarity.
    </div>

</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>RPCServer Library Documentation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: Consolas, Monaco, 'Andale Mono', monospace;
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        .note {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
        }
        .warning {
            background-color: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 15px 0;
        }
        .example {
            background-color: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <h1>RPCServer Library Documentation</h1>

    <h2>Table des matières</h2>
    <ul>
        <li><a href="#architecture">Architecture et concepts</a></li>
        <li><a href="#declaration">Déclaration des méthodes RPC</a></li>
        <li><a href="#custom-server">Création d'un serveur API personnalisé</a></li>
        <li><a href="#events">Gestion des événements</a></li>
        <li><a href="#examples">Exemples d'utilisation</a></li>
        <li><a href="#implementation">Détails d'implémentation</a></li>
    </ul>

    <h2 id="architecture">Architecture et concepts</h2>
    
    <h3>Vue d'ensemble</h3>
    <p>
        Le RPCServer est conçu pour exposer des APIs via différents protocoles tout en gardant la logique métier 
        indépendante du protocole. L'architecture est modulaire et extensible.
    </p>

    <h4>Composants principaux</h4>
    <ul>
        <li>
            <strong>RPCServer</strong>
            <ul>
                <li>Gestionnaire central des méthodes RPC</li>
                <li>Enregistre les méthodes et leurs handlers</li>
                <li>Gère la documentation automatique</li>
                <li>Coordonne les différents serveurs de protocole</li>
                <li>Diffuse les événements</li>
            </ul>
        </li>
        <li>
            <strong>APIServer</strong>
            <ul>
                <li>Classe de base abstraite pour les serveurs de protocole</li>
                <li>Déclare les capacités supportées (GET/SET/EVT)</li>
                <li>Gère les requêtes spécifiques au protocole</li>
            </ul>
        </li>
        <li>
            <strong>RPCMethod</strong>
            <ul>
                <li>Décrit une méthode RPC</li>
                <li>Type (GET/SET/EVT)</li>
                <li>Paramètres d'entrée/sortie</li>
                <li>Handler de traitement</li>
                <li>Documentation</li>
            </ul>
        </li>
    </ul>

    <div class="example">
        <h4>Exemple d'initialisation basique</h4>
        <pre><code>
RPCServer rpcServer;
auto& webServer = rpcServer.createWebServer(80);
rpcServer.begin();

void loop() {
    rpcServer.poll();
}
        </code></pre>
    </div>

    <h2 id="declaration">Déclaration des méthodes RPC</h2>

    <h3>Le Builder Pattern</h3>
    <p>
        La déclaration des méthodes utilise le pattern Builder pour une syntaxe fluide et type-safe.
        Les méthodes peuvent être de type GET, SET ou EVT.
    </p>

    <div class="example">
        <h4>Exemple de déclaration d'une méthode GET</h4>
        <pre><code>
rpcServer.registerMethod("device/status",
    RPCMethodBuilder(RPCMethodType::GET, [this](const JsonObject* args, JsonObject& response) {
        // Handler code
        return true;
    })
    .desc("Get device status")
    .response("enabled", "bool")
    .response("temperature", "float")
    .build()
);
        </code></pre>
    </div>

    <h3>Types de paramètres supportés</h3>
    <ul>
        <li><code>bool</code> : Booléen</li>
        <li><code>int</code> : Entier</li>
        <li><code>float</code> : Nombre à virgule</li>
        <li><code>string</code> : Chaîne de caractères</li>
        <li><code>obj</code> : Objet complexe</li>
    </ul>

    <h3>Objets imbriqués</h3>
    <p>
        La bibliothèque supporte les objets imbriqués à n'importe quel niveau de profondeur grâce à une 
        implémentation récursive.
    </p>

    <div class="example">
        <h4>Exemple d'objet imbriqué</h4>
        <pre><code>
.response("status", {
    {"wifi", {
        {"enabled", "bool"},
        {"rssi", "int"},
        {"config", {
            {"ssid", "string"},
            {"password", "string"}
        }}
    }}
})
        </code></pre>
    </div>

    <h2 id="custom-server">Création d'un serveur API personnalisé</h2>

    <p>
        Pour créer un nouveau serveur de protocole, il faut hériter de la classe APIServer et implémenter
        les méthodes virtuelles.
    </p>

    <div class="example">
        <h4>Exemple de serveur personnalisé</h4>
        <pre><code>
class MyCustomServer : public APIServer {
public:
    MyCustomServer(RPCServer& rpcServer) : APIServer(rpcServer) {
        addProtocol("custom", GET | SET | EVT);
    }
    
    void begin() override {
        // Initialisation
    }
    
    void poll() override {
        // Traitement périodique
    }
    
    void handleGet(const String& path, const JsonObject* args, JsonObject& response) override {
        // Gestion des requêtes GET
    }
    
    void handleSet(const String& path, const JsonObject& args, JsonObject& response) override {
        // Gestion des requêtes SET
    }
    
    void pushEvent(const String& event, const JsonObject& data) override {
        // Diffusion des événements
    }
};
        </code></pre>
    </div>

    <h2 id="events">Gestion des événements</h2>

    <p>
        Les événements (EVT) permettent d'envoyer des notifications asynchrones aux clients.
        Ils sont déclarés comme des méthodes RPC mais sans handler.
    </p>

    <div class="example">
        <h4>Déclaration d'un événement</h4>
        <pre><code>
rpcServer.registerMethod("device/events",
    RPCMethodBuilder(RPCMethodType::EVT)
    .desc("Device status updates")
    .response("type", "string")
    .response("data", {
        {"status", "string"},
        {"timestamp", "int"}
    })
    .build()
);
        </code></pre>

        <h4>Diffusion d'un événement</h4>
        <pre><code>
StaticJsonDocument<1024> doc;
JsonObject data = doc.to<JsonObject>();
data["type"] = "status_change";
data["timestamp"] = millis();
rpcServer.broadcast("device/events", data);
        </code></pre>
    </div>

    <h2 id="implementation">Détails d'implémentation</h2>

    <h3>Gestion de la mémoire</h3>
    <ul>
        <li>Utilisation de <code>StaticJsonDocument</code> pour les buffers JSON</li>
        <li>Taille par défaut : 2048 bytes pour la documentation</li>
        <li>Smart pointers pour les serveurs de protocole</li>
    </ul>

    <h3>Thread Safety</h3>
    <ul>
        <li>Mutex pour la queue d'événements WebSocket</li>
        <li>Taille de queue limitée (10 messages)</li>
        <li>Intervalle minimum entre les notifications (50ms)</li>
    </ul>

    <div class="note">
        <h4>Note sur la validation des paramètres</h4>
        <p>
            La validation des paramètres est volontairement simple :
            <ul>
                <li>Vérification de la présence des paramètres requis</li>
                <li>Pas de validation des types (géré par ArduinoJson)</li>
                <li>Pas de validation récursive des objets imbriqués</li>
            </ul>
        </p>
    </div>

    <div class="warning">
        <h4>Limitations</h4>
        <ul>
            <li>Taille fixe des documents JSON</li>
            <li>Pas de validation des types à l'exécution</li>
            <li>Pas de support des tableaux dans les paramètres</li>
        </ul>
    </div>

</body>
</html> 